---
title: "Peak detection for qualitative XRD analysis in R"
description: |
  A short description of the post.
author:
  - name: Ben Trueman
    url: 
date: 06-29-2021
bibliography: references.bib
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library("tidyverse")
theme_set(theme_minimal())
```

```{r load}
library("fffprocessr") # for peak detection
data <- read_csv("xrd_data.csv", skip = 13) %>% 
  rename(two_theta = DATA, intensity = X2) %>% 
  # scale to [0,1]:
  mutate(
    two_theta = as.numeric(two_theta),
    intensity = intensity - min(intensity, na.rm = TRUE),
    intensity = intensity / max(intensity, na.rm = TRUE)
  ) %>% 
  filter_all(all_vars(!is.na(.))) %>% 
  correct_baseline(left = 15, right = 55, group_vars = NULL, x_var = "two_theta", y_var = "intensity")

stds <- read_csv("xrd_stds.csv")
```

The data, from @trueman_etal_2018.

```{r}

label_axes <- function(...) {
  labs(
    x = expression("2"*theta~"(Cu K"*alpha*")"),
    y = "Normalized response",
    ...
  )
}

custom_colour_scale <- function(n = 3, ...) {
  scale_colour_manual(values = wesanderson::wes_palette("Zissou1", n))
}

data %>% 
  ggplot(aes(two_theta, intensity)) + 
  geom_line() + 
  label_axes()
```

A quick and dirty method of determining phase importance, for plotting purposes only:

```{r correlations}

xrd_corr <- function(run, standard) {
  list( 
      sample = run, 
      std = standard
    ) %>% 
    bind_rows(.id = "type") %>% 
    pivot_wider(id_cols = two_theta, names_from = type, values_from = intensity) %>% 
    group_by(two_theta = round(two_theta)) %>% 
    summarize(sample = median(sample, na.rm = TRUE), std = median(std, na.rm = TRUE)) %>% 
    ungroup() %>% 
    with(cor(sample, std, use = "complete", method = "pearson"))
}

importance <- stds %>% 
  distinct(phase) %>% 
  pull(phase) %>% 
  set_names() %>% 
  map_dfc(
    ~ xrd_corr(
        run = data,
        standard = filter(stds, phase == .x) %>% distinct()
    )
  ) %>% 
  pivot_longer(everything(), names_to = "phase", values_to = "r") %>% 
  arrange(desc(r))

```

```{r data-w-stds}

ordered_stds <- stds %>% 
  mutate(phase_f = factor(phase) %>% fct_relevel(importance$phase) %>% as.numeric())

data %>% 
  ggplot(aes(two_theta, intensity)) + 
  geom_line() +
  geom_segment(
    data = ordered_stds,
    aes(
      x = two_theta, xend = two_theta, 
      y = .25 * (0 - phase_f), yend = .25 * (intensity - phase_f), 
      col = phase
    )
  ) + 
  scale_y_continuous(breaks = seq(0, 1, .25)) +
  label_axes(col = NULL) + 
  custom_colour_scale()

```
Detect peaks:

```{r}

peaks_detected <- data %>% 
  mutate(grp = cut_number(intensity, 50)) %>% 
  peak_maxima(
    peaks = 30, n = 7, method = "sigma", 
     x_var = "two_theta", y_var = "intensity",
    group_vars = "grp"
  )

assign_peaks <- function(sample, standard, round_to = 1, phases) { 
  sample %>% 
    mutate(two_theta_rnd = plyr::round_any(two_theta, round_to)) %>% 
    right_join(
      standard %>% 
        filter(phase %in% phases) %>% 
        mutate(two_theta_rnd = plyr::round_any(two_theta, round_to)) %>% 
        select(two_theta, two_theta_rnd, phase), 
      by = "two_theta_rnd", suffix = c("", "_std")
    ) %>% 
    group_by(two_theta = round(two_theta_std, 1), phase) %>%
    summarize(intensity = max(intensity)) %>%
    ungroup()
}

peaks_idd <- bind_rows(
  assign_peaks(peaks_detected, stds, phases = importance$phase[1], round_to = .5),
  assign_peaks(peaks_detected, stds, phases = importance$phase[2], round_to = .5),
  assign_peaks(peaks_detected, stds, phases = importance$phase[3], round_to = .5)
)

```

Add the identified peaks to the plot:

```{r data-w-peaks}

data %>% 
  ggplot(aes(two_theta, intensity)) + 
  geom_line() +
  geom_segment(
    data = ordered_stds,
    aes(
      x = two_theta, xend = two_theta, 
      y = .25 * (0 - phase_f), yend = .25 * (intensity - phase_f), 
      col = phase
    )
  ) + 
  geom_point(
    data = peaks_idd,
    aes(col = phase)
  ) + 
  scale_y_continuous(breaks = seq(0, 1, .25)) +
  label_axes(col = NULL) + 
  custom_colour_scale()

```


